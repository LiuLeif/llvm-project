#+TITLE: Toy RISC-V Backend
#+AUTHOR: Wei Sun (孙伟)
#+EMAIL: wei.sun@hexintek.com
#+DATE: 2023-05-19 Fri 14:00
#+CATEGORY:
#+FILETAGS:

* Toy RISC-V Backend

** toy-1: llc 识别 target

*** 目标

#+begin_example
  $> ./build/bin/llc --version
  LLVM (http://llvm.org/):
    LLVM version 15.0.0git
    DEBUG build with assertions.
    Default target: x86_64-unknown-linux-gnu
    Host CPU: skylake

    Registered Targets:
      toy - TOY
#+end_example

*** 需要的修改

1. 添加 target 到 cmake

   #+begin_example
     set(LLVM_ALL_TARGETS
     ...
     Toy
     ...
     )
   #+end_example

   这个 `Toy` 与 build 时指定的 `LLVM_TARGETS_TO_BUILD=Toy` 一致, 且 cmake 会根
   据这个名字找到 `llvm/lib/Target/Toy` 目录来编译

2. 添加 Triple::ArchType

   #+begin_src C++ :eval no
     class Triple {
       public:
         enum ArchType {
             UnknownArch,
             ...
             toy,
             ...
         };
   #+end_src

   后面提到的 LLVMInitializeToyTargetInfo 函数会使 llc 的命令行参数 `-march toy`
   会对应到 ArchType::toy, 同时 LLVMInitializeToyTargetInfo 还会注册
   ArchType::toy 对应的 TheToyTarget, 从而让 llc 找到 TheToyTarget. 后续实现的
   Toy 的其它初始化的信息都会与 TheToyTarget 关联

3. 添加 llvm/lib/Target/Toy 目录

   1) 需要实现一个名为 LLVMToyCodeGen 的库 (这个名字是由 cmake 要求的), 并实现
      LLVMInitializeToyTarget 函数, 目前实现为空

   2) 需要实现一个名为 LLVMToyDesc 的库, 实现 LLVMInitializeToyTargetMC 函数, 目
      前实现为空

   3) 需要实现一个名为 LLVMToyInfo 的库, 实现 LLVMInitializeToyTargetInfo 函数.
      为了 llc 的 `Registered Targets` 能列出 toy, 这里必须实现该函数, 以便把
      `toy`, `Triple::toy` 以及 `TheToyTarget` 关联起来

*** 测试

#+begin_example
  $> ./build/bin/llc --version
  LLVM (http://llvm.org/):
    LLVM version 15.0.0git
    DEBUG build with assertions.
    Default target: x86_64-unknown-linux-gnu
    Host CPU: skylake

    Registered Targets:
      toy - Toy RISC-V backend

  $> clang toy_test/test.c -c -emit-llvm -O0 -o /tmp/test.bc
  $> ./build/bin/llc /tmp/test.bc -march=toy

  llc: /home/sunway/source/llvm-toy/llvm/tools/llc/llc.cpp:559: auto
  compileModule(char **, llvm::LLVMContext &)::(anonymous
  class)::operator()(llvm::StringRef) const: Assertion `Target && "Could not
  allocate target machine!"' failed.
#+end_example

报错的原因是:

#+begin_src C :eval no
  /* NOTE: 由于 LLVMInitializeToyTarget 没有实现, 导致
   ,* TheTarget.TargetMachineCtorFn 没有定义, TheTarget->createTargetMachine 返回
   ,* NULL */
  Target = std::unique_ptr<TargetMachine>(TheTarget->createTargetMachine(
      TheTriple.getTriple(), CPUStr, FeaturesStr, Options, RM,
      codegen::getExplicitCodeModel(), OLvl));
  assert(Target && "Could not allocate target machine!");
#+end_src

** toy-2: LLVMInitializeToyTarget

实现 LLVMInitializeToyTarget.

RegisterTargetMachine 会设置 TheTarget 的 TargetMachineCtorFn, 使得
TheTarget->createTargetMachine 返回 ToyTargetMachine 实例.

*** 测试

#+begin_example
  $> toy_test.sh
  llc: /home/sunway/source/llvm-toy/llvm/lib/CodeGen/LLVMTargetMachine.cpp:42:
  void llvm::LLVMTargetMachine::initAsmInfo(): Assertion `MRI && "Unable to create
  reg info"' failed.
#+end_example

出错的原因是没有调用 RegisterMCRegInfo, 导致 initAsmInfo 时出错.

** toy-3: LLVMInitializeToyTargetMC

LLVMInitializeToyTargetMC 会设置一个回调函数, 这些回调会由 initAsm 时通过
TheTargt 的 createXXX 调用以初始化 TheTarget 的 MRI, MII, STI, AsmInfo 等.

- MRI

  MCRegisterInfo

  寄存器的编号, 名字等, 主要信息由 td 生成

- MII

  MCInstrInfo

  指令的编码, 名字等, 主要信息由 td 生成

- STI

  MCSubtargetInfo

  subtarget 对应调用 llc 时指定的 `-mcpu`, `-mattr` 等信息. llc 会用这些信息调用
  STI 对应的回调函数以初始化 STI.

  subtarget 的信息是由 td 生成的

- AsmInfo

  MCAsmInfo

  需要包含一些 asm 文件的格式信息, 例如 comment 对应的 `#` 符号

在定义 STI 时使用了 td 文件, td 文件需要在 cmake 中指定 tablegen 命令的参数以及
生成头文件的名字, 例如

#+begin_example
  set(LLVM_TARGET_DEFINITIONS Toy.td)
  tablegen(LLVM ToyGenSubtargetInfo.inc -gen-subtarget)
  add_public_tablegen_target(ToyCommonTableGen)
#+end_example

表示 td 的入口是 Toy.td, 使用 `-gen-subtarget` 生成 ToyGenSubtargetInfo.inc

*** 测试

#+begin_example
  ~/source/llvm-toy#toy[17:43:49]@sunway-t14> ./toy_test.sh
  ; ModuleID = '/tmp/test.bc'
  source_filename = "toy_test/test.c"
  target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
  target triple = "x86_64-pc-linux-gnu"

  ; Function Attrs: noinline nounwind optnone uwtable
  define dso_local void @foo() #0 {
    %1 = alloca i32, align 4
    store i32 255, i32* %1, align 4
    ret void
  }

  ...
  !llvm.module.flags = !{!0}
  !llvm.ident = !{!1}

  !0 = !{i32 1, !"wchar_size", i32 4}
  !1 = !{!"clang version 10.0.0-4ubuntu1 "}
  llc: error: target does not support generation of this file type
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#+end_example

报错的原因是 Toy 没有指定一个 SelectionDAGISel 实例. SelectionDAGISel 是整个 isel
(instruction selection) 的入口

** toy-4: ToyDAGToDAGISel

通过 ToyTargetMachine 的 createPassConfig 函数, 注册一个 ToyDAGToDAGISel pass,
后者继承自 SelectionDAGISel, 需要实现一个 `Select` 函数做为 isel 的入口. 这里的
Select 函数直接调用了 td 根据 patten 生成的 SelectCode 函数. tablegen 的
`gen-dag-isel` 需要 td 中定义一个 RegisterClass

*** 测试

#+begin_example
  $> ./toy_test.sh

  llc: /home/sunway/source/llvm-toy/llvm/lib/MC/MCAsmStreamer.cpp:85: (anonymous
  namespace)::MCAsmStreamer::MCAsmStreamer(llvm::MCContext &,
  std::unique_ptr<formatted_raw_ostream>, bool, bool, llvm::MCInstPrinter *,
  std::unique_ptr<MCCodeEmitter>, std::unique_ptr<MCAsmBackend>, bool): Assertion
  `InstPrinter' failed.
#+end_example

出错的原因是没有实现 InstPrinter

** toy-5: ToyInstPrinter

ToyInstPrinter 继承自 MCInstPrinter, 需要实现 printInst, printRegName,
printOperand 等函数. 它会使用 tablegen 的 `-gen-asm-writer` 生成的函数例如
printInstruction, getRegisterName 等

*** 测试

#+begin_example
  $> ./toy_test.sh
  llc: error: target does not support generation of this file type
#+end_example

出错的原因是没有实现 ToyAsmPrinter.

cmake 通过提供 target 目录是否存在 `*AsmPrinter.cpp` 来决定 llc 是否调用
LLVMInitializeToyAsmPrinter 来初始化到 asm printer.

#+begin_example
  llvm/CMakeLists.txt:
  ====================
  file(GLOB asmp_file "${td}/*AsmPrinter.cpp")
    if( asmp_file )
      set(LLVM_ENUM_ASM_PRINTERS
        "${LLVM_ENUM_ASM_PRINTERS}LLVM_ASM_PRINTER(${t})\n")
  endif()

  AsmPrinters.def.in:
  ====================
  @LLVM_ENUM_ASM_PRINTERS@

  如果前面找到 AsmPrinter.cpp, 则这里会展开成:

  LLVM_ASM_PRINTER(Toy)

  llc:
  ====================
  inline void InitializeAllAsmPrinters() {
  #define LLVM_ASM_PRINTER(TargetName) LLVMInitialize##TargetName##AsmPrinter();
  #include "llvm/Config/AsmPrinters.def"
  }
#+end_example

所以需要定义一个 ToyAsmPrinter.cpp, 并实现 LLVMInitializeToyAsmPrinter 函数

** toy-6: ToyAsmPrinter

ToyAsmPrinter 操作的是 MachineInstr, 它需要实现 emitStartOfAsmFile,
emitFunctionBodyStart, emitInstruction 等, 其中 emitInstruction 需要转换
MachineInstr 到 MCInstr, 然后通过 MC 调用到 ToyInstPrinter

*** 测试

#+begin_example
  $> ./toy_test.sh

  llc: /home/sunway/source/llvm-toy/llvm/tools/llc/llc.cpp:733: int
  compileModule(char **, llvm::LLVMContext &): Assertion
  `LLVMTM.getObjFileLowering() && "getObjFileLowering"' failed.
#+end_example

报错的原因是 ToyTargetMachine 没有实现 getObjFileLowering 函数

** toy-7: ToyTargetObjectFile

AsmPrinter 会使用 TargetLoweringObjectFile 决定各种数据所在的 section

*** 测试

#+begin_example
  $> ./toy_test.sh

  llc: /home/sunway/source/llvm-toy/llvm/lib/CodeGen/ExpandLargeDivRem.cpp:119:
  virtual bool (anonymous
  namespace)::ExpandLargeDivRemLegacyPass::runOnFunction(llvm::Function &):
  Assertion `TM->getSubtargetImpl(F)' failed.
#+end_example

出错的原因是不支持 subtarget

** toy-8: ToySubtarget

ToyTargetMachine 需要实现 getSubtargetImpl 返回一个 ToySubtaget, 后续 isel 相关的功能
例如 getRegisterInfo, getInstrInfo, getFrameLowering, getTargetLowering 都需要由
subtarget 提供

*** 测试

#+begin_example
  $> ./toy_test.sh

  llc: /home/sunway/source/llvm-toy/llvm/lib/CodeGen/ExpandLargeDivRem.cpp:121:
  virtual bool (anonymous
  namespace)::ExpandLargeDivRemLegacyPass::runOnFunction(llvm::Function &):
  Assertion `TLI && "getTargetLowering is null"' failed.
#+end_example

出错的原因是 ToySubtarget 没有实现 getTargetLowering.

** toy-9: ToyTargetLowering

TargetLowering 在 SelectionDAGBuilder 阶段会被调用, 用来生成最初的
SelectionDAG. 虽然最初的 SelectionDAG 基本是 target 无关, 但涉及到函数调用及其参
数, 返回值的处理时需要 target 提供 TargetLowering 类, 并实现 LowerReturn 等函数

*** 测试

#+begin_example
  $> ./toy_test.sh

  llc: /home/sunway/source/llvm-toy/llvm/lib/CodeGen/MachineFunction.cpp:193: void
  llvm::MachineFunction::init(): Assertion `STI->getFrameLowering()' failed.
#+end_example

出错的原因是 ToySubtarget 没有实现 getFrameLowering

** toy-10: ToyFrameLowering

ToyFrameLowering 需要实现 emitPrologue 和 emitEpilogue, 它们由 PEI (prologue
epilogue insertion) 这个 pass 调用.

emitPrologue 会获取 stack size, 然后通过 BuildMI 生成 MachineInstr 来调整 sp. 另
外它还会生成 dwarf cfi directive.

PEI 操作的是 MachineInstr, 它发生成 scheduling 之后.

*** 测试

#+begin_example
  $> ./toy_test.sh

  llc:
  /home/sunway/source/llvm-toy/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp:3058:
  void llvm::SelectionDAGISel::SelectCodeCommon(llvm::SDNode *, const unsigned
  char *, unsigned int): Assertion `MatcherIndex < TableSize && "Invalid index"'
  failed.
#+end_example

出错的原因是 td 还没有定义 load pattern 对应的指令

** toy-11: isel

写一个最简单的 ToyInstrInfo.td, 它会把 immediate 这个 pattern 转换为 Toy::ADDI,
并且把用于访问局部变量的 frameindex 转换为 Toy::STORE

#+begin_example
  ===== Instruction selection begins: %bb.0 ''

  ISEL: Starting selection on root node: t5: ch = store<(store (s32) into %ir.1)> t0, Constant:i32<255>, FrameIndex:i32<0>, undef:i32
  ISEL: Starting pattern match
  Creating constant: t7: i32 = TargetConstant<0>
    Morphed node: t5: ch = STORE<Mem:(store (s32) into %ir.1)> Constant:i32<255>, TargetFrameIndex:i32<0>, TargetConstant:i32<0>, t0
  ISEL: Match complete!

  ISEL: Starting selection on root node: t1: i32 = Constant<255>
  ISEL: Starting pattern match
    Initial Opcode index to 51
  Creating constant: t9: i32 = TargetConstant<255>
    Morphed node: t1: i32 = ADDI Register:i32 $physreg1, TargetConstant:i32<255>
  ISEL: Match complete!

  ISEL: Starting selection on root node: t0: ch,glue = EntryToken

  ===== Instruction selection ends:
  Selected selection DAG: %bb.0 'foo:'
  SelectionDAG has 7 nodes:
      t1: i32 = ADDI Register:i32 $physreg1, TargetConstant:i32<255>
      t0: ch,glue = EntryToken
    t5: ch = STORE<Mem:(store (s32) into %ir.1)> t1, TargetFrameIndex:i32<0>, TargetConstant:i32<0>, t0
#+end_example

*** 测试

#+begin_example
  $> ./toy_test.sh

  llc:
  /home/sunway/source/llvm-toy/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:368:
  virtual void (anonymous namespace)::ScheduleDAGRRList::Schedule(): Assertion
  `TRI' failed.
#+end_example

出错的原因是 schedule 时需要 subtarget 实现 getRegisterInfo

** toy-12: ToyRegisterInfo

ToyRegisterInfo 需要实现 `getCalleeSavedRegs` 等函数, 后续 RA, PEI 等会使用它

*** 测试

#+begin_example
  $> ./toy_test.sh

  ,*** Final schedule ***
  SU(1): t1: i32 = ADDI Register:i32 $zero, TargetConstant:i32<255>

  SU(0): t5: ch = STORE<Mem:(store (s32) into %ir.1)> t1, TargetFrameIndex:i32<0>,
  TargetConstant:i32<0>, t0
  ...
  Target didn't implement TargetInstrInfo::storeRegToStackSlot!

  Stack dump:
  0.      Program arguments: ./build/bin/llc /tmp/test.bc -march=toy --debug
  1.      Running pass 'Function Pass Manager' on module '/tmp/test.bc'.
  2.      Running pass 'Prologue/Epilogue Insertion & Frame Finalization' on function '@foo'
   ...

  #9 0x000000000134b9d2 insertCSRSaves(llvm::MachineBasicBlock&,
   llvm::ArrayRef<llvm::CalleeSavedInfo>)
   /home/sunway/source/llvm-toy/llvm/lib/CodeGen/PrologEpilogInserter.cpp:602:5

  #10 0x0000000001348994 (anonymous
  namespace)::PEI::spillCalleeSavedRegs(llvm::MachineFunction&)
  /home/sunway/source/llvm-toy/llvm/lib/CodeGen/PrologEpilogInserter.cpp:681:41

  #11 0x000000000134768a (anonymous
  namespace)::PEI::runOnMachineFunction(llvm::MachineFunction&)
  /home/sunway/source/llvm-toy/llvm/lib/CodeGen/PrologEpilogInserter.cpp:252:3

#+end_example

出错的原因是 PEI 生成 prologue 时为了把 CSR 保存到栈上, 需要实现 storeRegToStackSlot

** toy-13: storeRegToStackSlot

storeRegToStackSlot 需要生成 MachineInstr, 把 reg (例如 RA) 保存到栈上

*** 测试

#+begin_example
  $> ./toy_test.sh

  Found roots: %bb.0
  Skipping pass 'Shrink Wrapping analysis' on function foo
  alloc FI(1) at SP[-4]
  alloc FI(0) at SP[-8]
  STORE killed $ra, %stack.1, 0
  STORE killed $ra, %stack.1, 0
  STORE killed $ra, %stack.1, 0
  STORE killed $ra, %stack.1, 0
  ....
#+end_example

程序陷入死循环, 原因是 eliminateFrameIndex 目前实现为空.

** toy-14: eliminateFrameIndex

PEI 会调用 eliminateFrameIndex 把使用了 frameindex 的 MachineInstr (例如 `STORE
ra, addr, 0`) 修改成 `STORE ra, sp, N`.

eliminateFrameIndex 需要根据 frameindex 的值以及 stack_size 计算出正确的偏移量,
然后修改 MI 的 operand, 把原来的 (addr, 0)替换成 (sp, offset)

*** 测试

#+begin_example
  $> ./toy_test.sh

  EmitInstruction not implemented
  UNREACHABLE executed at /home/sunway/source/llvm-toy/llvm/include/llvm/CodeGen/AsmPrinter.h:572!
  Stack dump:
  ...
  #9 0x0000000000c410f6 llvm::AsmPrinter::emitFunctionBody()
  /home/sunway/source/llvm-toy/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:1725:13
 
  #10 0x0000000000c10671
  llvm::AsmPrinter::runOnMachineFunction(llvm::MachineFunction&)
  /home/sunway/source/llvm-toy/llvm/include/llvm/CodeGen/AsmPrinter.h:4
  ...
#+end_example

出错的原因是没有实现 AsmPrinter 的 emitInstruction

** toy-15: emitInstruction

AsmPrinter 可以重写许多 emit 函数, 例如 emitFunctionBodyStart 等, 但这些都为默认
的实现. 但 emitInstruction 是 target 必需实现的.

emitInstruction 的功能是把 MachineInstr 转换为 MCInst, 然后交给 MCStream, 后者会
调用到 MCInstPrinter 中的接口, 例如 printInst

*** 测试

#+begin_example
  ./toy_test.sh

  Debug Range Extension: foo
          .globl  foo                             # -- Begin function foo
          .type   foo,@function
  foo:                                    # @foo
  # %bb.0:






  Lfunc_end0:
          .size   foo, Lfunc_end0-foo
                                          # -- End function

#+end_example

llc 能正常结束, 但输出的 asm 基本为空, 原因是 ToyInstPrinter 中 printInst 等目前
的实现为空

** toy-16: printInst

ToyInstPrinter 需要使用 td 生成的信息来实现 printInst, printRegName 等

*** 测试

#+begin_example
  $> ./toy_test.sh


  Debug Range Extension: foo
          .globl  foo                             # -- Begin function foo
          .type   foo,@function
  foo:                                    # @foo
  # %bb.0:
          sw      ra, 4(sp)
          addi    ra, zero, 255
          sw      ra, 0(sp)
          addi    ra, zero, 255
          sw      ra, 0(sp)
          sw      ra, 0(sp)
  Lfunc_end0:
          .size   foo, Lfunc_end0-foo
                                          # -- End function
#+end_example

针对 mem operand 使用了自定义的 printMemOperand, 而不会调用默认的 printOperand.

现在的代码看起来有两个问题:

1. addi 不应用使用 ra, 需要定义更多的 register
2. 最后两行 `sw ra, 0(sp)` 是什么

** toy-17: add registers

*** 测试

#+begin_example
  $> ./toy_test.sh

  Debug Range Extension: foo
          .globl  foo                             # -- Begin function foo
          .type   foo,@function
  foo:                                    # @foo
  # %bb.0:
          addi    t0, zero, 255
          sw      t0, 0(sp)
  Lfunc_end0:
          .size   foo, Lfunc_end0-foo
                                          # -- End function
#+end_example

** toy-18: add more insns

添加 store/add/and/or/andi/ori 指令. 由于目前不涉及到 object 文件的生成, 所以去
掉了 td 中关于指令格式的内容.

添加指令时 patten 可以有两种写法:

1. 写在 Instruct 的 patten 中, 例如:

   #+begin_example
     def LOAD : ToyInst<(outs GPR:$ra), (ins mem:$addr), "lw \t$ra, $addr",
               [(set GPR:$ra, (load AddrFI:$addr))],
               IIAlu>;
   #+end_example

2. 使用 Pat, 例如:

   #+begin_example
     def LOAD : ToyInst<(outs GPR:$ra), (ins mem:$addr), "lw \t$ra, $addr", [], IIAlu>;

     def : Pat<(load AddrFI:$addr),
               (LOAD  AddrFI:$addr)>;
   #+end_example

** toy-19: simplify insn definition

定义 ADD, DIV, REM, ... 时有许多重复的内容, 可以使用 td 的 class 简化这些指令
的定义

** toy-20: global address

目前 toy 还不支持 global address, 所以编译下面的程序会报错:

#+begin_example
  $> cat toy_test/test.c
  int x = 0;
  void foo() {
      int l = x;
  }

  $> ./toy_test.sh

  LLVM ERROR: Cannot select: t4: i32,ch = load<(dereferenceable load (s32) from
  @x)> t0, GlobalAddress:i32<ptr @x> 0, undef:i32
#+end_example

对于 global address 的处理发生成 legalize 阶段, ToyTargetLower 需要通过
`setOperationAction` 标记 ISD::GlobalAddress 的 action 为 custom, 同时实现
LowerOperation 来处理这个 node: 生成 `add (lui %hi(x)) %lo(x))` 对应的 node

*** 测试

#+begin_example
  $> ./toy_test.sh

  ===== Instruction selection ends:
  Selected selection DAG: %bb.0 'foo:'
  SelectionDAG has 9 nodes:
        t9: i32 = LUI TargetGlobalAddress:i32<ptr @x> 0 [TF=1]
      t10: i32 = ADDI t9, TargetGlobalAddress:i32<ptr @x> 0 [TF=2]
      t0: ch,glue = EntryToken
    t4: i32,ch = LOAD<Mem:(dereferenceable load (s32) from @x)> t10, t0
    t6: ch = STORE<Mem:(store (s32) into %ir.1)> t4, TargetFrameIndex:i32<0>, TargetConstant:i32<0>, t4:1
  ...
  foo:                                    # @foo
  # %bb.0:
  unknown operand type
  UNREACHABLE executed at /home/sunway/source/llvm-toy/llvm/lib/Target/Toy/ToyMCInstLower.cpp:25!

  ...

  #8 0x0000000000c26775 llvm::ToyMCInstLower::LowerOperand(llvm::MachineOperand
  const&) const
  /home/sunway/source/llvm-toy/llvm/lib/Target/Toy/ToyMCInstLower.cpp:27:33
#+end_example

isel 成功, 但在 AsmPrinter 时出错, 因为 LUI 及 ADDI 的 operand 是 GlobalAddress,
当前的 LowerOperand 只支持 register 和 imm

** toy-21: directly lower to machine code

前面的 LowerOperation 把 global address lower 成了 ISD:ADD, 实际上可以直接 lower
成 Toy::ADDI, 省略后续 isel 时 ISD::ADD 到 Toy::ADDI 的过程. 由于 isel 的输入可
能是 machine code, 所以 ToyDAGToDAGISel 的 Select 需要忽略掉 SDNode 已经是
machine code 的情况

** toy-22: lower MachineOperand to MCOperand

前面 LUI 转换成 MacineInstr 后它的 MachineOperand 是
MO_GlobalAddress. ToyMCInstLower 的 LowerOperand 需要把它 lower 成
MCOperand.

这个 MCOperand 的 kind 既不是 register, 也不是 immediate, 因此需要定义ToyMCExpr,
做为 MCOperand 的 expr.

ToyMCExpr 保存着原始的 imm 和 kind (hi/lo) 信息. ToyInstPrinter 会调用到
ToyMCExpr::printImpl 最终根据它保存的 kind 打印出 `%hi` 和 `%lo`

** toy-23: store global variable

前面的代码不支持全局变量的赋值, 因为缺少 `store $rs1, $rs2` 这个 pattern

** toy-24: LowerReturn

return 语句需要通过 ToyISelLowering::LowerReturn 处理. 这个过程发生在最初的
SelectionDAGBuilder 阶段.

LowerReturn 需要分析需要 return 的值, 生成一些指令把这些值按调用约定处理 (放在寄
存器, 放在栈上), 最后还生成一个 ToyISD::Ret.

目前的 LowerReturn 只处理了 return void 的情况

ToyISD::Ret 使用了自带的 PseudoInstExpansion 机制, 后者会使用 tablegen 生成和
ToyMCInstLower 类似的代码, 把 Toy::Ret lower 成 JALR 对应的 MCInst.

如果不考虑生成 obj, 也可以直接 =def RET : InstI<(outs),(ins), "jalr zero,0(ra)",
[(ToyRET)], IIAlu>;=, 这样使用默认的 ToyMCInstLower 就可以处理.

** toy-25: emitPrologue and emitEpilogue

当前生成的代码是错误的, 例如:

#+begin_example
  $> cat test.c
  void foo() {
      int x = 1;
      int y = x;
      int z = y;
  }

  $> ./toy_test.sh
  foo:                                    # @foo
  # %bb.0:
          addi    t0, zero, 1
          sw      t0, 8(sp)
          lw      t0, 8(sp)
          sw      t0, 4(sp)
          lw      t0, 4(sp)
          sw      t0, 0(sp)
          jalr zero, 0(ra)
#+end_example

foo 的入口需要有 `addi sp, sp, -12`, 称为 prologue
foo 的返回前需要有 `addi sp, sp, 12`, 称为 epilogue

其中 `8` 是 stack size, 取决于:

1. 是否保存 fp, 如果有 fp 且没有使用 omit-frame-pointer 则需要保存

2. 是否保存 ra, 如果函数不是 leaf function 则需要保存

3. 是否保存 callee saved reg (CSR), 如果函数使用了它们, 则需要保存和恢复

4. 局部变量占用的栈空间

5. ...

emitPrologue 本身并不负责 CSR 的 spill 和 restore, 它们由 PEI 负责
(spillCalleeSavedRegs)

emitPrologue 发生在 schedule 及 RA 之后, 所以它们操作的是 MachineInstr 和物理寄
存器

epilogue 与 prologue 对应, 但如果函数不需要返回, 则不需要 epilogue (参考
ToyInstrInfo.td 中的 `isReturn = 1`)

** toy-26: LowerCall

call 需要 ToyISelLowering::LowerCall 来处理, 它负责按调用约定处理函数调用的参数
(例如放在特定物理寄存器或放在栈上), 然后生成跳转指令, 并处理函数返回的结果 (例如
从特定物理寄存器或栈上获得结果)

当前的实现只生成了跳转指令, 所以只能支持 `void foo()` 类型的函数调用

*** 测试

#+begin_example
  #> ./toy_test.sh

          .text
          .file   "test.c"
          .globl  foo                             # -- Begin function foo
          .type   foo,@function
  foo:                                    # @foo
  # %bb.0:
          lui t0, %hi(foo)
          addi    t0, t0, %lo(foo)
          jalr ra, 0(t0)
          jalr zero, 0(ra)
  Lfunc_end0:
          .size   foo, Lfunc_end0-foo
                                          # -- End function
#+end_example

能生成 `jalr ra, 0(t0)` , 但有一个问题: 没有针对 ra 做 CSR 的 spill 和 restore

** toy-27: LowerCall cont.

CSR 需要保存的前提是函数不是 leaf function, 通过设置 td 中 CALL 指令 `isCall =
1` 让 llvm 知道函数 `hasCalls()`

由于 RA 寄存器 并非由 register allocator 分配, 所以需要重写
determineCalleeSaves, 把 RA 加到 SavedRegs 里

最后需要实现 loadRegFromStackSlot, 以便生成 restore ra 的指令
